## はじめに

ご覧いただきありがとうございます。通称Nyanyanです。ハードウェアを作っている物理や折紙、スピードキューブなどが好きな人です。ここではMonoMotionで、3Dモデル作成支援システムとしてご説明したReficereが、実際に内部で何をやっているのかについてご説明していきます。

この記事のターゲットは**数式に威圧されたい方々や物理・数学が好きな方**を考えており、ある程度丁寧には書きましたが重要ではない細かい説明(途中式等)は省いています。細かな技法についての説明も省きますが、後述の「蛇足」に書くこともあります。途中計算はまとめてこのページの最後に手書きのノートですが載せてあります。

また、図の説明などは誤解のないよう丁寧に書いていることもありますので、**冗長に感じたのであれば読み飛ばしてください**。大事そうなところは太字にしましたので、それも参考までにして読んでいただければと思います。

本質的にはあまり重要ではないものや少し専門的なことや、逆に専門的な内容のちょっとした説明で書きたいことや、理解のちょっとした手助けになりそうなことがあるときは、私の好きなある本にならって(本来の言葉の意味とは少し外れるかもしれませんが)「**蛇足**」という項目で(区別がつきやすいように引用の形式で)まとめて書いておきます。

蛇足

> 私の友達(理系の高3)にこれを読んでもらったところ、何を言っているのかわからないとの指摘を受けたので、未踏の成果報告会にと同時にこれを公開した時よりも全体像をはっきりさせ、こういう余計なことは蛇足にまとめて書くようにしました。これで少しは読みやすくなったと思います。
>
> この文章は基本的に修学旅行の夜や疲れた日の夜に書いているので、つまりは深夜テンションです。少し変なところがあるかもしれませんが、そんなにガチガチのアカデミックなものを書いているつもりはないので、気楽に読んでいただければと思います。

## 概要

Reficereは、**ロボットの各リンク(関節に挟まれた部分: 太ももや脛等)の重量測定と重心位置の計算を支援するシステム**です。まずは下の動画を軽く御覧ください(中に出てくる式は私の書き間違いにより一部間違っています)。

[![](https://img.youtube.com/vi/nECBQznYx9g/0.jpg)](https://www.youtube.com/watch?v=nECBQznYx9g)

これまで、ロボットの3Dモデル(URDFを想定、図0)を作成するには、ロボットの各リンクの大きさを測り、分解して重量測定をしたりする必要がありました。特に重量測定では**分解が面倒**な上に、単純な方法ではリンク内の**重心位置を求めることができませんでした**。リンク内重心位置は地味ですが正確なロボットの3Dモデルを作るには結構大事です。

図0: 3Dモデルの例(手作りのYamaX 4.0というロボット)

![fig0]({{require('./images/fig0.png')}})

Reficereでは重量測定の問題を大幅に改善し、あるリンクより上に位置するリンク全ての重量がわかれば、そのリンクの重量とリンク内での重心位置が、**放って置くだけで、短時間に、実用に耐えうる精度をもって**計測できます。これはつまり、ロボットの最上位リンクの重量がわかれば**全てのリンクの重量が漸化式のように芋づる式に計測可能**だということです(もちろんそうでない場合もあります)。

これを実現するため、Reficereでは**重心センサ兼重量センサ**(重心センサ)を製作し、使用しました(なにか「特殊」な値がわからないと目的の数値の測定はできなくて、手頃に測れそうなのが重心だったというだけです)。詳しい説明は別途しますが、ロードセルと呼ばれる、電子天びんに使われる重量センサを4つ使ったものです。

図1は今回の計測で重要になる値を無理やり押し込んだ図です。文字の説明もしていないし煩雑なので、雰囲気だけ味わっていただければと思います。最終目標は図1での$\boldsymbol{w_n}$(求めるリンク(ターゲットリンク)の重さ)と$\boldsymbol{H_n}$(ターゲットリンク内での重心位置)の2つを求めることですが、未知数の多さにより単純な測定では求められないので、**3回の計測によって必要な数値を(少しテクニカルな方法で)求めていきます。**

図1:

![fig1]({{require('./images/fig1.png')}})

蛇足

> URDFはなにかと言われると私もちゃんとした説明ができるか怪しいですが、私の認識では、「ロボットを記述」する方式や、それによって書いたモデル等を指すと考えています。ロボットの大きさ、重さ、重心位置、あとは色とか、そういった情報を記述したものだと思っています。
>
> Reficereでは計測不可能(ではないにしても少し工夫が必要)な場合というのは、例えばヒューマノイドロボットなら、ロールやピッチの軸が絡んでくる場合です。こういうときはReficereでも結構面倒です。そういう面倒さは少し残ってしまったので、Reficereは重量測定「支援」システムとしています。ロボットを少し改造したときにいちいち分解したくない！という時には特に重宝できるものかなと思います。

## 測定器具

### 器具

測定器具は単純で、ロボット本体と重心センサ(写真1、写真2)です。

写真1: 重心センサ 裏(地面側)から

![pic1]({{require('./images/pic1.jpg')}})

写真2: 重心センサ ロードセルをメインに

![pic2]({{require('./images/pic2.jpg')}})

ロードセルの詳しい使い方はここでは省略します。下のリンク等で確認できると思います。

https://www.denshi.club/cookbook/sensor/g/2001g.html

蛇足

>今回の重心センサには500gのロードセル(金属棒中央のゆがみによって重さを精密に量るセンサ)4つを使いました。CNCでMDFボードを少し削り、ひずみを持てる余裕を作ったん落ちにネジで固定しています。地面につく側はネジをナットで浮かせて作りました。このあたりの設計は適当極まりないので、参考程度です。
>
>写真で紙の下に使っていないロードセルがありますが、これはこのロードセルがもともとはロボットの足裏に設置したもので、8つまとめて配線してあったものを再利用し4つだけ使用しているからです。新しく作り直せば良いのですが、時間と気力のなさによりこうなりました。

### 重心測定の実装

これから説明していく測定では**よく重心の位置を利用**していきます。そのため、重心位置は高い精度をもって図らなければならなくて、それに少し**実装上の工夫**をしましたので軽く説明します。少し**細かい話**です。

測定した重心の生データは重心センサの上に載っているロボットの重さと重心だけでなく、**重心センサそのものの重さと重心位置をも反映した値**となっているはずです。このデータでは、ロボットについて精密な測定はできません。

そこで今回では、Reficere起動時には重心センサは空中に上げた状態とし、その状態でロードセルのオフセットをとり、その後に重心センサのみを地面の上に置き、重心センサ自体の重さと重心位置の測定を行うことでこの問題を**計算で補正**しました。また、重心位置の単位を[mm]で出力するため、センサ間の距離とロボットの足裏の長さを計測し、計算式を作成しました。これらは単純かつあまり本質とは関係ない式ですので、ページ最後に手書きの計算式を載せるのみとします。

ロードセルについて、HX711というADコンバータを挟んで使ったのですが、サンプリングレートを上げたところ少しノイズが入ったり、時々変な値が出たりしたので、何回か計測し、**最大最小10%ほどを除い平均**を使うことで対応しました。

蛇足

>重心センサにはセンサからのケーブルがあり、測定時にはそのケーブルを触るだけでも重心位置は変化するため、測定中はケーブルを地面に固定するなどの対策を取りました。
>
>複数回の計測をしたことで、センサのサンプリングレートを上げはしたものの、当初思ったほどには計測スピードは向上しませんでした。それでも精度を考えれば実用に問題はあまりないと思います。

## 測定・計算式

### 文字・言葉の定義

計算式には様々な文字が出てくるので、一旦ここで整理しておきます。それぞれの式にも文字の定義については言及してあると思いますので**気楽にお読みください**。

数値の種類には大きく分けて3つあります。**重さ**[g]、物理的な**長さ**[mm]、**重心位置の変化量**[mm]です。この順に書いていきます。

添字$n$は、リンクに上から番号をふっていったときの番号を示しています(一番上は0)。



$w_n​$: ターゲットリンクの重量[g] (Reficereで求める目的の値)

$W$: ロボットの全体重 (重心センサで計測)

$H_n$: ターゲットリンク内での重心位置の高さ[mm] (Reficereで求める目的の値)

$h_n$: ターゲットリンクより上位の全リンクの共通重心の高さ[mm] (測定Aで測定)

$l_n$: ターゲットリンクの上下を挟むジョイント間の距離[mm] (与える)

$x$: ロボットのホームポジション(直立等)からの重心位置の変化量[mm] (添字は計測の順番によるもの 重心センサで計測)

$\theta,\alpha_n,\alpha_{n-1},\beta,\gamma$: 関節を曲げた角度[rad] 詳しくは図を御覧ください (サーボの角度は推測や取得が可能)



蛇足

> 重心の高さは、対称とするリンクの直下についているジョイントから高さ方向に見た長さです。これが本当にわかりにくいです。測定の説明の中で図示したものも見つつ理解していただければ幸いです。

### 測定A: $\boldsymbol h_{n-1 }$を求める

#### 立式

測定Aでは$\boldsymbol{h_{n-1}}$**(上位リンク全ての共通重心の高さ)**を求めます。ここではターゲットリンクを図2の青色のリンクとし、赤丸はリンク内の重心位置と重量、黒丸はジョイント、黒棒はリンクを表します。赤字は未知の数量、黒字は既知の数量です。

図2: $h_{n-1}$の測定図

![fig2]({{require('./images/fig2.png')}})

図2のように、上位リンクを角度$\theta$だけ曲げたときの足裏での重心位置の変化量を$x_1$とすると、**重心周りのモーメント和**から、以下の式1が与えられます。ただし、$x_1$は重心位置の変化量、$W​$はロボット全体の重量です。

式1: $h_{n-1}$を求める計算式

![stmt1]({{require('./images/stmt1.png')}})

今回では**上位リンクの重量は与える**ことになっているので、この測定により$\boldsymbol h_{n-1}$**は既知の値のみで表すことができます**。

なお、$h_n$について、$H_n$と$w_n$が求まっている状態であれば、測定なしに以下の式で求められる場合もあります。

式1.1: $h_n$の別の計算式

![stmt1.1]({{require('./images/stmt1.1.png')}})

蛇足

> 今回の立式では、重心周りのモーメント和が0という条件式を頻繁に使います。正確には、「右回りのモーメント=左回りのモーメント」のような形で使っています。
>
> また、立式のコンセプトは言葉で書いていますが途中式を豪快に省いています。途中式などはこのページの最後に(手書きのノートのスキャンですが)載せてありますので、気になる方は御覧ください。

#### 実装

立式では特に単位は考えていませんが、実装では単位に気をつけることが必須です。今回ではReficere全体を通して、重量は[**g**]、長さは[**mm**]に統一しています(重心位置の変化量も単位は[mm]です)。また、角度の単位が度なのかラジアンなのかも重要です。今回では関数の実装の関係上**ラジアン**で書いています。

測定誤差についてですが、思考実験でも理解できると思いますが、**$\boldsymbol\theta$が0に近づけば近づくほど$\boldsymbol h_{n-1}$の測定誤差は大きくなります**。今回では計測回数を16回にし、使用する$θ$は90度から75度程度にしました。それに加え、16個のデータの最大最小それぞれ3個ずつを除外した中央10個のデータの平均値を出力しました。このあたりの個数は適当です。

蛇足

> 今回のデータ処理ですが、本来は統計的な処理をもう少し厳密にすべきかもしれません。しかしそれはReficereの根幹に関わるものだとは考えにくく、今回の適当な実装でも正確な値が出せると判断し、(かつ時間がなかったので)このような実装になっています。

### 測定B: $\boldsymbol \alpha_n$、$\boldsymbol \alpha_{n-1}$を計測する

#### 立式

測定Bでは、ターゲットリンクと上位リンク(のジョイント(面倒なので以下省略))をそれぞれ曲げたときに、重心位置が変化しない状態を探し、その時の**図3の示す角度$\boldsymbol \alpha_n​$、$\boldsymbol \alpha_{n-1}​$**を計測します。

図3:

![fig3]({{require('./images/fig3.png')}})

詳しくは実装の項目で書きますが、ロボット自体の制御は非常に単純明快です。

ここでの立式は、測定Bはホームポジションのときと**重心位置が変化しない**ことに留意して、上位リンクの重量と腕の長さ、ターゲットリンクの重量(未知)と腕の長さを利用して**モーメントの関係式**(式2)を作ることです。この式とこの測定だけでは何もわかりませんが、あとで使用します。

式2: 重心位置不動の状態を示す式

![stmt2]({{require('./images/stmt2.png')}})

蛇足

> 今回では簡単のため(且つこの制限によってReficereを使用可能な場合が限られることはそれほど多くないだろうという推測もあり)、$\alpha_n + \alpha_{n-1} = \pi / 2​$としました。関節の可動範囲が十分であれば、この制限はどんなロボットでもクリアできるはずです。しかし理論上ではこの角度は何度でも、少し計算式をいじることで対応できます。そのためにはこの解説に出てくる全ての式の$h_{n-1}​$と$\alpha _{n-1}​$を以下で$h_{n-1}'​$と$\alpha _{n-1}'​$に置換します。
>
> $\alpha_{n-1}'=\frac{\pi}{2}-\alpha_n​$
>
> $h_{n-1}'=h_{n-1} \frac{sin\alpha_{n-1}}{cos\alpha_{n}}​$
>
> ただし、この式の検証は十分でないです。

#### 実装

実装はいたって単純です。**$\boldsymbol \alpha_n + \boldsymbol \alpha_{n-1} = \boldsymbol \pi / \boldsymbol 2$を満たしながら、重心位置を計測し、目標値(0)との差からPID制御などをかける**だけです。今回では**P制御でも発振しなかった**ので(実装の時間の関係もあり)P制御だけで制御しています。

蛇足

> 今回P制御でうまくいったことについて、使用する関数の特徴が要因の一つとして考えられます。関節の角度を大きくしていくと重心位置は変化しますが、曲げる角度を大きくすれば大きくするほど、重心位置は変化しにくくなっていきます。つまり、角度を入力して重心位置を出力する関数を考えると、その関数は(制御する範囲での定義域で)単調増加上に凸または単調減少下に凸ということです。実際にこの関数はsin curveです。
>
> また、実は今回の実装はあまりよろしくなく、上部リンクを$\alpha_n + \alpha_{n-1} $曲げた後にターゲットリンクを曲げていく手法をとりました。これでは上部リンクが重かったり$h_{n-1}$が大きい(上部リンクの重心位置が高い)時にはロボットが倒れてしまう可能性があります。もっとうまい制御方法はあると思います(例えば$\alpha_n + \alpha_{n-1} ​$を徐々に大きくしていきながら重心位置0を保つ制御)。



### 測定C: $\boldsymbol \beta$を計測する

#### 立式

測定Cは全測定で一番理論が複雑なところですので、いくつか細かな項目に分けて少し丁寧に説明していきます。

全体像は図4、5です。図4で示す角度$\beta$を、図5の状態を作ることで計測します。

図4: $\beta$の示す角度

![fig4]({{require('./images/fig4.png')}})

図5: 測定Cの全体像

![fig5]({{require('./images/fig5.png')}})

測定Cでの一番重要な点は、図5で、**ターゲットリンクの重心と上位リンクの重心を結んだ線が地面と垂直**になるようにする点です。これによって未知数をうまく消していけます。

段階を追って詳しく内容を説明していきます。最初の2段階で未知数である$H_n$と$\gamma$を$\beta$(測定Cで求める未知数)を使って表し、3段階目で条件式を作ります。この際には前2段階の式を使い、**未知数は$\boldsymbol \beta$だけ**にします。

##### $\boldsymbol H_n$を$\boldsymbol \beta$を用いて表す

$H_n​$はReficereで最終的に導きたい未知数の一つですので、$H_n​$を測定Cで決定する未知数である$\boldsymbol \beta​$**を使って表す**と後々便利に使えます。測定Bの状態に補助線を足した図6での角度$\pi-(\alpha_{n-1}+\beta)​$に注目して、三角比の定義から式3が導けます。

図6: 必要な角と長さ

![fig6]({{require('./images/fig6.png')}})

式3: $H_n$を$\beta$で表す便利な式

![stmt3]({{require('./images/stmt3.png')}})

なお、式3では$tan​$内から$\pi​$という数値は**相互関係**を使って外しています。

蛇足

> Reficereの中ではよく、三角関数の基本公式(相互関係や加法定理)を使います。詳しくは以下のサイト等を御覧ください。
>
> https://mathtrain.jp/category/trigonometric

##### $\boldsymbol \gamma$の計算

図5での$\gamma$を$\beta$を使って表していきます。この際、図7で示す$\boldsymbol m$**の値**に着目します。

図7: 長さ$m$の定義

![fig7]({{require('./images/fig7.png')}})

図7より、式4が導け、式4と式3($H_n​$を$\beta​$で表す便利な式)から、最終的に導きたい形で式5が導けます。

式4: $m$を2通りで表してくっつける

![stmt4]({{require('./images/stmt4.png')}})

式5: $\gamma$と$\beta$の関係式

![stmt5]({{require('./images/stmt5.png')}})

##### 重心線が地面と垂直になる状態の関係式

$\beta$が正しい値のときに式5によって算出される$\gamma$をロボットに適用し、図5の状態を作ると、ターゲットリンクの重心位置と上位リンクの重心位置を結んだ線が地面と垂直になります。ここでは**垂直という条件を表す関係式**を導きます。具体的な方針としては、図5の状態で$\boldsymbol w_n$**を表す式を2つ作り、連立して$\boldsymbol w_n$を消す**だけですが、それぞれの式が非常に重いです。

###### $\boldsymbol w_n$を表す式1つ目

$w_n$を表す1つ目の式では、**式3**($H_n$を$\beta$で表す便利な式)と、三角関数の**加法定理**を用いた式の連立をしたものです。順を追って説明していきます。注目する三角形は測定Bの状態の、図8の**緑色の三角形**です(測定Cの状態ではありません)。長さ$s$と$t$は新たに定義しました。この長さは後で消去できるのでこのまま放っておきます。

図8: $sin(\alpha_n+\beta)$を求める

![fig8]({{require('./images/fig8.png')}})

これについて、$sin(\alpha_n+\beta)$を2通りで表します。緑色の三角形について素直に**三角比の定義と相互関係**を使って表すと式6になります。

式6: $sin(\alpha_n+\beta)$表し方1

![stmt6]({{require('./images/stmt6.png')}})

また、**加法定理**で$sin(\alpha_n+\beta)$を分解して、図から導ける式7を代入すると、式8ができます。

式7: $\beta​$の三角関数

![stmt7]({{require('./images/stmt7.png')}})

式8: $sin(\alpha_n+\beta)$表し方2

![stmt8]({{require('./images/stmt8.png')}})

式3($H_n$を$\beta$で表す便利な式)と式6と式8を連立して$H_n$、$\beta$、$s$、$t$を消去すると式9になります。

式9: $w_n$の表し方1

![stmt9]({{require('./images/stmt9.png')}})

測定Cの状態を表す式を作るために、2つの$w_n$を表す式を使うことにしたうちの1つが式9で出てきたところです。

蛇足

> $s$と$t$が$s+t$の形でしか出てこないのになぜ2つの文字を使ったのか不思議に思う方もいらっしゃると思います。これは(ページ最後の途中式を見ていただければわかると思いますが)もともと$s$のみで表せるものを無理やり$s+t$の形で表した結果です。
>
> また、いきなり式7で$sin\beta$と$cos\beta$が出てきて驚いた方もいらっしゃると思います。この辺の途中式は煩雑なためかなり大胆に省略しました。気になる方はページ最後の途中式を御覧ください。

###### $\boldsymbol w_n$を表す式2つ目

次は、$w_n$を表す2つ目の式です。次は重心位置の測定結果を使った表し方で、式9よりは単純です。

測定3の状態では、ターゲットリンクと上位リンク、それぞれの**重心を結んだ線は地面と垂直**になります。これに注意して$H_n$に着目して立式すると、式10ができます。$x_3$は重心位置の変化量、$W$はロボット全体の重量です。

式10: $w_n​$の表し方2の元の式

![stmt10]({{require('./images/stmt10.png')}})

これを式3($H_n$を$\beta$で表す便利な式)で$\boldsymbol H_n$**を消して整える**と式11ができます。

式11: $w_n​$の表し方2

![stmt11]({{require('./images/stmt11.png')}})

蛇足

> この記事を書いてる中で思ったのですが、ここの立式は$h_{n-1}​$と$\gamma​$に注目してもできると思います。

###### 測定Cの状態を表す式

式9と式11より、$\boldsymbol w_n$**を消去**して、測定Cの状態を表す式12ができます。

式12: 測定Cの状態を表す式

![stmt12]({{require('./images/stmt12.png')}})

蛇足

> 式12が汚い形をしているのは、もうこれ以上は人間が計算する必要がないから必要以上の変形をしていないことに一因があります。もちろん、計算量が少なければ実装したときの計算スピードも速くなると思いますが、このレベルの高速化はそこまで重要ではないと考えています。

#### 実装

測定Cは実装もまた複雑です。説明のためグラフ1を掲載します。グラフ1で最も大切なのが**青のグラフ**(式12の右辺と左辺の差)です。制御について簡単に説明すると、グラフ1で青のグラフが($\beta=\pi/2$以外で)**0を示す場合を探す**ことで測定Cで求める値である$\beta$求められます。

グラフ1: 理論値(事前に分解して測定した値)に基づいた測定Cのグラフ

![olot1]({{require('./images/plot1.png')}})

グラフ1で緑は、横軸$\beta$によって式5から算出した$\gamma$[度]、赤は$w_n$を実測した値から導いた、図6の状態でのロボット全体の重心位置$x_3$[mm]で、計測には関係ありますが実装には関係ない値です。

要するに、βが正しい値の時にのみ式12が成立するので、**式12の両辺の差分が0になる**ようにβを動かして調整すれば良いということです。この制御も本来はPID制御等でやるべきかもしれませんが、今回はP制御でうまくいきました。

蛇足

> このグラフでは角度の単位が[度]ですが、これはグラフの縦幅の大きさが度だときれいに見えるからです。
>
> 今回の実装では測定Bと測定Cで差分の閾値(0にこれだけ近かったら計測完了とする値)と、差分の変化量(PID制御ではD、微分した値)の閾値のそれぞれを使用して、正しい$\beta$がいくらかを制御の中で判断しています。時間を横軸、青のグラフの縦軸を縦軸にとった関数(関数1=P)の値が制御によって0に収束したとすると、その時、関数1を時間で微分した関数(関数2=D)の値も0に収束するはずです。このことを利用すれば、測定誤差や、一時的な外力等によってたまたま関数1の値が0に飛んだ場合に制御を終了してしまうことがなくなると考えました。ただ、私は真面目に大学で制御を勉強したわけではないので、このようなアプローチが「正しい」のかはわかりません。
>
> 結果的にですが、測定Cでは上位リンクを$\gamma$にある通り曲げることで、測定中のロボットの転倒も防げると考えています。

### 目的の値の計算

ここまでの3回の測定で、求めるべき未知の値は求まりました。これらを使えばすぐに目的の値($w_n$と$H_n$)が計算できます。ここでの計算方法はいろいろあると思いますが、今回では既出の以下の2式を使いました。

式9: $w_n$の計算式

![stmt9]({{require('./images/stmt9.png')}})

式3: $H_n​$の計算式

![stmt3]({{require('./images/stmt3.png')}})

## 最後に

ここまで読んでくださりありがとうございます。自分でも思った以上のボリュームになってしまいました。要するに**普通は計測できない値をどうにかこうにか計測してやろうという魂胆**なわけで、難しめ(？)の物理の問題を解いているようなものでした。ただ、物理の問題なら絶対に解けるという保証と解くのに必要な条件が全て明記されていますが、このようなシステムを作る時には解ける保証もなければ条件は自分で(実験で計測可能な)数値を与えることを考えなくてはならない点、回り道をしたりと労力の必要な作業でした。

このシステムの鍵は、重心位置を計測できることを利用してどう立式するかです。また、実装では単位系やロボットの制御、様々な問題が絡み合ってくる、あまり本質でないところで躓いてしまい、思った以上に手間取ってしまいました。ここは反省です。

Reficereの式はかなり複雑なのと時間がなかったのとで、数学的な検証が十分ではありません。desmosでグラフを描いて確認はしたつもりですが、もし興味のある方でなにか間違いを発見した方がいらっしゃいましたらご連絡ください。実際、自分でこの記事を書き直すタイミングでいくつかミスを発見しました。

下に、手書きのノートのスキャンではありますが、今回の**全ての計算式・途中式・図、重心測定関係の式**を載せます。ご活用ください。

ありがとうございました。

蛇足

> Reficcereは重量測定に着眼したシステムですが、URDF作成の手間は重量測定だけではなく、リンクの大きさを測ったりすること、そして計測したデータをURDFの形式に記述することもまた面倒なことです。今後も更に改善していけたら良いなと思います。

参考資料1: 計算式・途中式・図

![reference1]({{require('./images/reference1.png')}})

参考資料2: 重心測定関係の計算式

![reference2]({{require('./images/reference2.png')}})

## 変更履歴

2017/02/17頃 公開しました

2019/02/27頃 読みやすいように文章・図を大幅に修正しました。
